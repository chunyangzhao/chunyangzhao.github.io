---
title: data_race
date: 2020-08-15 21:36:56
tags:
---

# Data Race

### Data race案例

目前有变量int64 a，暂用64位，即8字节。

存在T1和T2两个线程同时对a进行W写操作，即W1(a)和W2(a)，且没有使用原子操作和加锁机制。

假设写操作可分为W(a-l32)和W(a-h32)两条指令，分别对应写变量a的低32位和高32位。

则目前存在四条指令分别是W1(a-l32)，W1(a-h32)，W2(a-l32)，W2(a-h32)

```
  案例1                          案例2                            案例3                          案例4
   T1       T2               T1       T2                      T1       T2                   T1       T2
W1(a-l32)                           W2(a-l32)             W1(a-l32)                                W2(a-l32)    
W1(a-h32)                 W1(a-l32)                                 W2(a-l32)            W1(a-l32)
         W2(a-l32)                  W2(a-h32)                       W2(a-h32)            W1(a-h32)
         W2(a-h32)        W1(a-h32)                       W1(a-h32)                                W2(a-h32)
```

如上为这四种指令可能发生的先后顺序（实际中不止这四种）

- 案例1中T2线程会覆盖T1线程的写操作，最后a为T2线程的值

- 案例2中T1线程会覆盖T2线程的写操作，最后a为T1线程的值

- 案例3中T2线程会覆盖T1线程的对a低32位的写操作，T1线程会覆盖T2线程的对a高32位的写操作，最后a既不是T1也不是T2的值

- 案例4中T1线程会覆盖T2线程的对a低32位的写操作，T2线程会覆盖T1线程的对a高32位的写操作，最后a既不是T1也不是T2的值

可见线程T1和T2在无锁和无原子操作的情况下，同时对变量a进行写操作，尽管a的值不确定，但

- 在案例1和案例2种，a的值尽管不确定，但始终是正确的值。

- 在案例3和案例4种，a的值既不是T1也不是T2的值，而是不存在的，错误的值。

### 乱序与data race的区别

案例1和案例2中的问题称为**乱序问题**。因为T1和T2对a期望的写顺序，即程序逻辑是由程序员人为制定的，一旦实际运行过程中违背了这个程序原本逻辑所期望的顺序，即出现了乱序，但这里没有出现数据不一致问题。

案例3和案例4中的问题称为**data race**，即数据不一致，产生错误数据的问题。

案例1和案例2虽然存在乱序问题，但没有发生data race。

*可见乱序问题是时序问题，不是数据不一致问题；而data race不是时序问题，而是数据一致性问题。*

### 避免data race的方法

- 原子操作：atomic, 如c++11中的atomic
- 加锁

***注意加锁和原子操作均不能避免乱序问题***

### 触发data race的条件

- 多线程

  data race只存在于多线程场景

- R/W，W/R，W/W读写类型

  以两个线程读写同一个地址为例，WW/WR/RW三种读写类型均可能存在data race，RR读写类型没有data race。以下面为例

  ```
          WW                        WR                              RW                              RR
     T1       T2               T1       T2                      T1       T2                   T1       T2
  W1(a-l32)                 W1(a-l32)                       R1(a-l32)                    R1(a-l32)             
            W2(a-l32)                 R2(a-h32)                       W2(a-l32)                       R2(a-l32)      
            W2(a-h32)       W1(a-h32)                                 W2(a-h32)          R1(a-h32)          
  W1(a-h32)                           R2(a-l32)             R1(a-h32)                                 R2(a-h32)   
  ```

  - WW:  变量a最终结果为W2(a-l32)和W1(a-h32)，存在data race
  - WR:  T2最终读取的结果为旧(a-h32)和W1(a-l32)，既未读到a的旧值，也未读到T1写的a的新值，存在data race
  - RW:  T2最终读取的结果为旧(a-l32)和W2(a-h32)，既未读到a的旧值，也未读到T1写的a的新值，存在data race
  - RR:  不管这四条指令如何排列，T1和T2均可以读到正确的a值

- 并发关系

  多个线程对同一地址的操作如果无法保证每个线程操作的先后顺序，则称为并发关系。

# Tsan

### Tsan编译选项

```
-fsanitize=thread
```

### Tsan代码位置

libsanitizer目录中存在以下两种工具的代码：

- tsan: 用于检测多线程场景中潜在的data race，即本文所用的工具

- asam: 用于检测内存泄露

### 检测方案

1. 通过编译器检测data race，需要提供5个信息：

   - 读写类型W/R

   - 当前线程的tid

   - 线程操作的地址address

   - 操作的地址大小size，1/2/4/8/16

   - 是否使用atomic或者加锁操作

     编译选项-tsan_read/write

2. 思考如何找到其余线程中对同一个地址的修改

